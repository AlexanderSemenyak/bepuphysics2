using BepuPhysics.Collidables;
using BepuUtilities;
using BepuUtilities.Collections;
using BepuUtilities.Memory;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;

namespace BepuPhysics.CollisionDetection
{
    public struct MeshReduction : ICollisionTestContinuation
    {
        /// <summary>
        /// Flag used to mark a contact as being generated by the face of a triangle in its feature id.
        /// </summary>
        public const int FaceCollisionFlag = 32768;
        public Buffer<Triangle> Triangles;
        //MeshReduction relies on all of a mesh's triangles being in slot B, as they appear in the mesh collision tasks.
        //However, the original user may have provided this pair in unknown order and triggered a flip. We'll compensate for that when examining contact positions.
        public bool RequiresFlip;
        //The triangles array is in the mesh's local space. In order to test any contacts against them, we need to be able to transform contacts.
        public BepuUtilities.Quaternion MeshOrientation;
        //This uses all of the nonconvex reduction's logic, so we just nest it.
        public NonconvexReduction Inner;

        public void Create(int childManifoldCount, BufferPool pool)
        {
            Inner.Create(childManifoldCount, pool);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe void OnChildCompleted<TCallbacks>(ref PairContinuation report, ConvexContactManifold* manifold, ref CollisionBatcher<TCallbacks> batcher)
            where TCallbacks : struct, ICollisionCallbacks
        {
            Inner.OnChildCompleted(ref report, manifold, ref batcher);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void OnChildCompletedEmpty<TCallbacks>(ref PairContinuation report, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks
        {
            Inner.OnChildCompletedEmpty(ref report, ref batcher);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryFlush<TCallbacks>(int pairId, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks
        {
            Debug.Assert(Inner.ChildCount > 0);
            if (Inner.CompletedChildCount == Inner.ChildCount)
            {
                //Before handing responsibility off to the nonconvex reduction, make sure that no contacts create nasty 'bumps' at the border of triangles.
                //Bumps can occur when an isolated triangle test detects a contact pointing outward, like when a box hits the side. This is fine when the triangle truly is isolated,
                //but if there's a neighboring triangle that's snugly connected, the user probably wants the two triangles to behave as a single coherent surface. So, contacts
                //with normals which wouldn't exist in the ideal 'continuous' form of the surface need to be corrected.

                //A contact is a candidate for correction if it meets three conditions:
                //1) The contact was not generated by a face collision, and
                //2) The contact position is touching another triangle, and
                //3) The contact normal is infringing on the neighbor's face voronoi region.

                //Contacts generated by face collisions are always immediately accepted without modification. 
                //The only time they can cause infringement is when the surface is concave, and in that case, the face normal is correct and will not cause any inappropriate bumps.

                //A contact that isn't touching a triangle can't infringe upon it.
                //Note that triangle-involved manifolds always generate contacts such that the position is on the triangle to make this test meaningful.
                //(That's why the MeshReduction has to be aware of whether the manifolds have been flipped- so that we know we're working with consistent slots.)

                //Contacts generated by face collisions are marked with a special feature id flag. If it is present, we can skip the contact. The collision tester also provided unique feature ids
                //beyond that flag, so we can strip the flag now. (We effectively just hijacked the feature id to store some temporary metadata.)



                //Now that boundary smoothing analysis is done, we no longer need the triangle list.
                batcher.Pool.Return(ref Triangles);
                Inner.Flush(pairId, ref batcher);
                return true;
            }
            return false;
        }
    }
}
